""" Git operations manager.
handles all git interactions: branching, committing , status checks."""

import subprocess
from typing import Optional,List
from pathlib import Path
from dataclasses import dataclass
from Rocket.Utils.logger import get_logger
logger = get_logger(__name__)


@dataclass
class GitStatus:
    """Current git repository status."""
    is_repo: bool
    current_branch: str
    is_clean: bool
    uncommitted_files: List[str]
    is_production_branch: bool


class GitError(Exception):
    """Git operation error."""
    pass


class GitManager:
    """Manages Git operations for Rocket AI Assistant.
    
    Handles:
    - Repository detection
    - Branch operations
    - Commit operations
    - Safety checks
    """
    
    PRODUCTION_BRANCHES = ['main', 'master', 'production', 'prod', 'release']
    
    def __init__(self, repo_path: Optional[Path] = None):
        """Initialize git manager.
        
        Args:
            repo_path: Path to git repository (default: current directory)
        """
        self.repo_path = repo_path or Path.cwd()
        logger.debug(f"GitManager initialized at: {self.repo_path}")
    
    def get_status(self) -> GitStatus:
        """Get current git repository status.
        
        Returns:
            GitStatus object with repository information
        """
        # Check if git repo
        is_repo = self._is_git_repo()
        
        if not is_repo:
            return GitStatus(
                is_repo=False,
                current_branch="",
                is_clean=True,
                uncommitted_files=[],
                is_production_branch=False
            )
        
        # Get current branch
        current_branch = self._get_current_branch()
        
        # Check if clean
        is_clean = self._is_working_tree_clean()
        
        # Get uncommitted files
        uncommitted_files = self._get_uncommitted_files()
        
        # Check if production branch
        is_production = current_branch in self.PRODUCTION_BRANCHES
        
        return GitStatus(
            is_repo=True,
            current_branch=current_branch,
            is_clean=is_clean,
            uncommitted_files=uncommitted_files,
            is_production_branch=is_production
        )
    
    def create_branch(self, branch_name: str, base_branch: Optional[str] = None) -> str:
        """Create and checkout new branch.
        
        Args:
            branch_name: Name for new branch
            base_branch: Branch to create from (default: current branch)
        
        Returns:
            Name of created branch
        
        Raises:
            GitError: If branch creation fails
        """
        try:
            # Validate branch names - only allow alphanumeric, hyphens, underscores, slashes
            import re
            branch_pattern = r'^[a-zA-Z0-9._/-]+$'
            if not re.match(branch_pattern, branch_name):
                raise GitError(f"Invalid branch name: {branch_name}. Use only alphanumeric, hyphens, underscores, dots, or slashes.")
            
            if base_branch and not re.match(branch_pattern, base_branch):
                raise GitError(f"Invalid base branch name: {base_branch}. Use only alphanumeric, hyphens, underscores, dots, or slashes.")
            
            # Check if branch exists
            if self._branch_exists(branch_name):
                # Generate unique name
                import datetime
                timestamp = datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
                branch_name = f"{branch_name}-{timestamp}"
                logger.warning(f"Branch exists, using: {branch_name}")
            
            # Create and checkout branch - using list prevents shell injection
            if base_branch:
                cmd = ['git', 'checkout', '-b', branch_name, base_branch]
            else:
                cmd = ['git', 'checkout', '-b', branch_name]
            
            subprocess.run(
                cmd,
                cwd=self.repo_path,
                capture_output=True,
                text=True,
                check=True,
                shell=False
            )
            
            logger.info(f"Created branch: {branch_name}")
            return branch_name
        
        except subprocess.CalledProcessError as e:
            raise GitError(f"Failed to create branch: {e.stderr.strip()}") from e
    
    def commit_changes(
        self,
        files: List[str],
        message: str,
        add_rocket_signature: bool = True
    ) -> str:
        """Stage and commit changes.
        
        Args:
            files: List of files to commit
            message: Commit message
            add_rocket_signature: Add "Generated by Rocket CLI" to message
        
        Returns:
            Commit hash
        
        Raises:
            GitError: If commit fails
        """
        try:
            # Validate file paths to prevent path traversal attacks
            for f in files:
                # Ensure no suspicious path patterns
                if '..' in f or f.startswith('/'):
                    raise GitError(f"Invalid file path: {f}")
            
            # Stage files - using list prevents shell injection
            subprocess.run(
                ['git', 'add'] + files,
                cwd=self.repo_path,
                check=True,
                shell=False
            )
            
            # Build commit message with validation
            full_message = message
            if add_rocket_signature:
                full_message += "\n\nGenerated by Rocket CLI"
            
            # Validate commit message doesn't contain suspicious patterns
            if any(char in full_message for char in ['$', '`', '|', '&', ';']):
                raise GitError(f"Invalid characters in commit message")
            
            # Commit
            result = subprocess.run(
                ['git', 'commit', '-m', full_message],
                cwd=self.repo_path,
                capture_output=True,
                text=True,
                check=True,
                shell=False
            )
            
            logger.info(f"Committed changes: {result.stdout.strip()}")
            return result.stdout.strip()
        
        except subprocess.CalledProcessError as e:
            raise GitError(f"Failed to commit changes: {e.stderr.strip()}") from e
    
    def stash_changes(self, message: Optional[str] = None) -> bool:
        """Stash uncommitted changes.
        
        Args:
            message: Stash message
        
        Returns:
            True if changes were stashed
        """
        try:
            cmd = ['git', 'stash']
            if message:
                # Validate message doesn't contain shell metacharacters
                if any(char in message for char in ['$', '`', '|', '&', ';', '\n']):
                    raise GitError(f"Invalid characters in stash message")
                cmd.extend(['save', message])
            
            result = subprocess.run(
                cmd,
                cwd=self.repo_path,
                capture_output=True,
                text=True,
                check=True,
                shell=False
            )
            
            # Check if anything was stashed
            stashed = "No local changes to save" not in result.stdout
            
            if stashed:
                logger.info("Changes stashed")
            
            return stashed
        
        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to stash: {e.stderr}")
            return False
    
    def get_diff(self, staged: bool = True) -> str:
        """Get diff of changes.
        
        Args:
            staged: Get staged changes (default: True)
        
        Returns:
            Diff output
        """
        try:
            cmd = ['git', 'diff']
            if staged:
                cmd.append('--staged')
            
            result = subprocess.run(
                cmd,
                cwd=self.repo_path,
                capture_output=True,
                text=True,
                check=True,
                shell=False
            )
            
            return result.stdout
        
        except subprocess.CalledProcessError:
            return ""
    
    # Private helper methods
    
    def _is_git_repo(self) -> bool:
        """Check if current directory is a git repository."""
        try:
            subprocess.run(
                ['git', 'rev-parse', '--git-dir'],
                cwd=self.repo_path,
                capture_output=True,
                check=True,
                shell=False
            )
            return True
        
        except subprocess.CalledProcessError:
            return False
    
    def _get_current_branch(self) -> str:
        """Get current branch name."""
        try:
            result = subprocess.run(
                ['git', 'branch', '--show-current'],
                cwd=self.repo_path,
                capture_output=True,
                text=True,
                check=True,
                shell=False
            )
            return result.stdout.strip()
        
        except subprocess.CalledProcessError:
            return ""
    
    def _is_working_tree_clean(self) -> bool:
        """Check if working tree is clean."""
        try:
            result = subprocess.run(
                ['git', 'status', '--porcelain'],
                cwd=self.repo_path,
                capture_output=True,
                text=True,
                check=True,
                shell=False
            )
            return len(result.stdout.strip()) == 0
        
        except subprocess.CalledProcessError:
            return False
    
    def _get_uncommitted_files(self) -> List[str]:
        """Get list of uncommitted files."""
        try:
            result = subprocess.run(
                ['git', 'status', '--porcelain'],
                cwd=self.repo_path,
                capture_output=True,
                text=True,
                check=True,
                shell=False
            )
            
            # Parse git status output - format: "MM filename" or "M filename"
            files = [line[3:].strip() for line in result.stdout.splitlines() if line.strip()]
            
            return files
        
        except subprocess.CalledProcessError:
            return []
    
    def _branch_exists(self, branch_name: str) -> bool:
        """Check if branch exists."""
        try:
            # Use list elements to prevent string interpolation issues
            ref_path = 'refs/heads/' + branch_name
            subprocess.run(
                ['git', 'show-ref', '--verify', ref_path],
                cwd=self.repo_path,
                capture_output=True,
                check=True,
                shell=False
            )
            return True
        
        except subprocess.CalledProcessError:
            return False
    
    def _get_latest_commit_hash(self) -> str:
        """Get hash of latest commit."""
        try:
            result = subprocess.run(
                ['git', 'rev-parse', 'HEAD'],
                cwd=self.repo_path,
                capture_output=True,
                text=True,
                check=True,
                shell=False
            )
            return result.stdout.strip()
        
        except subprocess.CalledProcessError:
            return ""